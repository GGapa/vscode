## 洛谷秋令营提高组第二次模拟赛

## A. 优美的环

### 算法一

发现题目的意思，就是将所有相同的数字聚到一起。

对于 $n \leq 20$，使用状态压缩 DP 算出答案。

### 算法二

对于每个 $1$，假设其位置变化为 $a_i$（即顺时针移动了多少步，如果是逆时针就是负数），则若 $a_i$ 都非零，则令 $p = \sum_{i=1}^n [a_i > 0], q = \sum_{i=1}^n [a_i < 0]$。

若 $p \neq q$，不妨设 $p > q$，则将所有 $a_i$ 减去 $1$，答案符合并且步数变少。$p < q$ 类似。

若 $p = q$，则可以通过将所有 $a_i$ 加上或减去 $1$ 让答案不变。

在此断言，存在最优解，使得存在 $a_i = 0$。

也就是可以枚举不动的点，然后以这个点为环中心，其余点顺时针或逆时针移动。在此过程若存在 $u$ 顺时针走，使得路径上存在 $v$，使得 $v$ 一开始是 $1$，并且这个一是逆时针移动的，那么答案一定不是最优的。

所以在此基础上可以枚举另一个分界点，即可直接答案算出。

记不动的点为 $S$，分界点为 $T$，则只需要分别对 $S$ 到 $T$ 顺时针和逆时针路径上的 $1$ 分配位置，计算距离。

时间复杂度 $O(n^3)$。

### 算法三

若对算法二中计算距离部分使用前缀和优化，时间复杂度可以降到 $O(n^2)$。

### 算法四

注意开 long long。

换个方法枚举，因为不动点只可能是环上连续的一段，所以枚举顺逆时针的分界点。以分界点为起点将环展开成一个序列（可以使用倍长序列取区间的方法）。

在此断言，在枚举完分界点的前提下，存在对于当前分界点的最优解，使得不动点覆盖到序列上所有 $1$ 的中位数（对于偶数长度可以指定第 $\frac{\text{一的个数}}{2}$ 个）。

如果没覆盖到中位数，不妨设不动点在中位数逆时针方向，则引用算法二，负数个数 $\geq \lfloor \frac{\text{一的个数} + 1}{2}\rfloor$，即不断顺时针移动所有点会使答案不变劣。这样调整总能将中位数变成不动点。

于是只要取中位数，并且使用算法三中的前缀和优化即可做到 $O(n)$。

## B. 最近的城市

### 算法一

floyd，复杂度 $O(n^3)$

### 算法二

堆优化的 dijkstra 跑全源最短路，复杂度 $O(n(n \log n + m))$。

### 算法三

考虑 dijkstra 的过程，因为有距离单调性，所以对于一个点 $u$，如果其在最近的 $k$ 个点之内，则其只有至多 $k$ 个出边（边权最小的那几条）有用，因为对于更多的边会产生大于 $k$ 条距离不比它近的。

于是每次用 dijkstra 找到 $k$ 个点，每个点最多用 $k$ 条出边即可。

std 用的是普通堆优化，复杂度 $O(n k^2 \log k)$。

如果用斐波那契堆，复杂度 $O(n k^2)$。

## C. 最短的道路

### 算法一

floyd，复杂度 $O(P^3)$。

### 算法二

堆优化的 dijkstra 跑全源最短路，复杂度 $O(P^2 \log P)$。

### 算法三

如果不存在 $0 < a < P - 1$ 使得 $k^a = 1 \pmod P$，则说明可以通过边权为 $0$ 的边到达任意点，输出 $0$ 即可。对应着测试数据中的特殊性质。

### 算法四

如果 $k = 1$，说明乘法没什么用，加法只能加 $0$，所以只有可能 $u = v$ 是有路径的，输出 $0$，否则输出 $-1$。对应着测试数据中的特殊性质。

其实对于 $k = 0$ 和 $k = 1$ 的判断是一样的，只不过是 $K = 0$ 没有任何边。

### 算法五

特判 $K = 0$ 或 $1$。

找到最小的 $a > 0$ 使得 $k^a = 1 \pmod P$，那么路径对编号的效果可以表达为

$$
v = b_0 + b_1 k + b_2 k^2 + \dots + b_{a - 1} k^{a - 1} + k^{c} u
$$

因为 $k \geq a$ 的效果和 $k - a$ 时是一样的，所以只需要 $b_0$ 到 $b_{a - 1}$ 表示。

那么就可以枚举 $c$，并且预处理通过路径得到 $v - k^cu$ 的最短路是多少，这里可以使用 01-bfs，因为可以将边拆点为 $(u, u + 1, 1)$：虽然变换是 $ku + i$，但是在加之前通过乘上 $k^{a - 1}$ 得到 $u' = u k^{a-1}$，此时 $ku'+i = u + i$。

使用 01-bfs 复杂度 $O(P)$，每次询问复杂度 $O(a)$，总复杂度 $O(Qa)$。

### 算法六

对于 $u$ 和 $k u \mod p$ 是等价的，所以可以将图缩点，分成 $O(\frac{P}{a})$ 个等价类。此时直接连边跑全源最短路，如果使用 floyd 复杂度是 $O(\frac{P^3}{a^3})$，如果使用 01-bfs 复杂度是 $O(\min(\frac{P^2}{a},\frac{P^3}{a^3}))$。

### 算法七

结合算法五六，进行数据分治得到算法六中使用 floyd 复杂度是 $O(\sqrt[4]{P^3Q^3})$，可以通过此题，使用 01-bfs 可以获得更优秀的结果。

## D. 关住羊群

### 算法一

因为当 $n > 1$ 时如果两个集合有交，则有方案从两个集合中删去交的元素，符合题目条件且答案不会变劣。

所以直接 $O(2^n)$ 枚举对于 $i$，$i \in S$ 还是 $i \in T$。

### 算法二

对坐标进行离散化，记 $f_{i,x,y,u,v}$ 为枚举到第 $i$ 只羊，$(\max_{i \in S} x_i + \max_{i \in S} y_i) + (\max_{i \in T} u_i + \max_{i \in T} v_i)$ 的四个 $\max$ 值分别是 $x, y, u, v$ 的可行性，则可以直接 $dp$。

复杂度 $O(n^5)$。

### 算法三

直接枚举 $x = \max_{i \in S} x_i, y = \max_{i \in S} y_i$，则所有 $x_i \leq x，y_i \leq y$ 都应该在 $S$ 内，其余的都不应该在。

所以离散化后枚举，只需要 $O(n^3)$ 的复杂度。

### 算法四

通过二维数点，算出不满足 $x_i \leq x，y_i \leq y$ 的点中 $u_i$ 和 $v_i$ 的 $\max$。

复杂度 $O(n^2 \log n)$。

### 算法五

其实不用二维数点，只需要分别算出 $x_i \geq x$，$y_i \geq y$ 的 $u, v$，合并起来即可。

通过预处理，复杂度 $O(n^2)$。

### 算法六

从小到大枚举 $x$，则 $(u, v)$ 的计算分为两部分：$x_i > x$ 这部分非常好算，一个后缀 $\max$ 就好。对于 $x_i \leq x$，对于固定的 $y$，$u, v$ 会随着 $x$ 增加而单调增。

于是对于 $(x, y, u, v)$，相当于在所有 $y' < y$ 的位置对于 $u$ 和 $v$ 两维分别取 $\max$。

答案的计算是 $x$ 加上枚举的位置 $y + u + v$。

因为取 $\max$ 是前缀的区间操作，所以相当于找到对应区间并覆盖，对于这点维护区间最大最小值，即可在线段树上操作。

于是对于 $y$ 的增加，其 $u, v$ 是单调减的，不妨讨论 $u$，当 $u$ 比原序列后缀最大值还要小的时候，就没用了。

所以区间分成几种情况：用了对应位置上的 $u, v$ 或者用了后缀最大值的 $u, v$。对应这种情况需要维护 $y + u + v$，$y + u$，$y + v$ 的最小值。（对于 $y$ 的最小值，因为是排过序的，取最左边的即可）

由于随着 $x$ 增加 $u, v$ 单调不降，后缀最大值单调不增，所以可以用量个单调的指针来寻找线段树上的后缀，使得后缀上的 $u$ 或 $v$ 是小于对应后缀最大值的。

询问被两个指针分为三个区间，只需要调用线段树查询，并且注意边界情况即可。

时间复杂度 $O(n \log n)$。
